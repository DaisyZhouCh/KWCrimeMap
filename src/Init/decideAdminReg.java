package Init;/** * Created by chongyizhou on 2016-11-16. */import DAO.*;import com.mongodb.Block;import com.mongodb.client.FindIterable;import org.bson.Document;import org.json.JSONArray;import org.json.JSONObject;import java.io.*;import java.util.ArrayList;import java.util.HashSet;import java.util.*;import java.util.concurrent.CountDownLatch;//taken every node for every administrative region polygon, then loop records, to decide which polygon every record belongs topublic class decideAdminReg {    private DbHelper db = new DbHelperImpl();    private void closeMongo() {        this.db.closeMongo();    }    private DbHelper getDb() { return this.db;}    // to judge if a point is in a polygon    public static boolean isPolygonContainsPoint(int vert, ArrayList<Float> vertx, ArrayList<Float> verty, float testx, float testy) {        int nCross = 0;        int i, j = 0;        for (i = 0, j = vert-1; i < vert; j = i++) {            // p1 p2 means node i and node j            //LatLng p1 = mPoints.get(i);            //LatLng p2 = mPoints.get((i + 1) % mPoints.size());            // 求解 y=p.y 与 p1p2 的交点            if (verty.get(i) == verty.get(j)) // p1p2 与 y=p0.y平行                continue;            // 交点在p1p2延长线上            if (testy < Math.min(verty.get(i), verty.get(j)))                continue;            // 交点在p1p2延长线上            if (testy >= Math.max(verty.get(i), verty.get(j)))                continue;            // 求交点的 X 坐标            float x = (testy - verty.get(i)) * (vertx.get(j) - vertx.get(i))                    / (verty.get(j) - verty.get(i)) + vertx.get(i);            if (x > testx)                nCross++; // 只统计单边交点        }        // 单边交点为偶数，点在多边形之外 ---        return (nCross % 2 == 1);    }    public String pointToPolygon(JSONObject polygon, ArrayList<Float> point) {    // latitude and longitude of a point are stored in an array        FindIterable<Document> result;        String adminRegion = "NULL";        Set<String> polysNames = new HashSet<String>();        polysNames = polygon.keySet();        int regSum = polysNames.size();        if (point == null || point.size() <=1) {            return adminRegion;        }        for (String s : polysNames) {            ArrayList<Float> vertx = new ArrayList<Float>();            ArrayList<Float> verty = new ArrayList<Float>();            // s is a polygon's name            // s is a list of dictionaries            JSONArray polyNodes = polygon.getJSONArray(s);            // polyNodes is a list of dictionaries            int vertxLength = polyNodes.length();            //System.out.println("adminRegion:" + s + ", polygon:" + vertxLength + ";");            for (int i = 0; i < vertxLength; i++) {                // polyNodes[i] is a dictionary for a node in a polygon                JSONObject node = polyNodes.getJSONObject(i);                vertx.add(Float.parseFloat(node.getString("latitude")));                verty.add(Float.parseFloat(node.getString("longitude")));            }            if (point.size() == 2) {                try {                    //point.get(0) is point's latitude, point.get(1) is longitude                    float x = Float.valueOf(point.get(0)+"f");                    float y = Float.valueOf(point.get(1)+"f");                    boolean judge = isPolygonContainsPoint(vertxLength, vertx, verty,x, y);                    //System.out.println(judge);                    if (judge == true) {                        adminRegion = s;                    }                } catch (IndexOutOfBoundsException e) {                    e.printStackTrace();                    continue;                }            }        }        // below has reached all node of polygons, then to read every record nodes        return adminRegion;    }    public static void main(String[] args)throws Exception {        CountDownLatch latch = new CountDownLatch(1);        File file = new File("locations.json");        FileReader fr = new FileReader(file);        BufferedReader br = new BufferedReader(fr);        String s;        s = br.readLine();        final JSONObject polygonJson = new JSONObject(s);        decideAdminReg dar = new decideAdminReg();/*        ArrayList<Float> arr = new ArrayList<Float>();        arr.add(43.43179051498936f);        arr.add(-80.52631919584674f);        String result = dar.pointToPolygon(polygonJson, arr);        System.out.println("the result is: " + result);*/        DbHelper db = dar.getDb();        //change the crime_collections one by one to ensure every collection has been updated        FindIterable<Document> result = db.selectByField("crime_collection2011", "geographicLocation");        Iterable result_itera = result;        //System.out.println(Iterables.size(result_itera));        ArrayList<Integer> count = new ArrayList<Integer>();        result.forEach( new Block<Document>() {            public void apply(final Document document) {                System.out.println(document);                ArrayList<Float> locArray;                String adminRegion = "NULL";                try{                    locArray = (ArrayList<Float>) document.get("geographicLocation");                    System.out.println("locArray is:" + locArray);                    //adminRegion = dar.pointToPolygon(polygonJson, locArray);                } catch (ClassCastException e) {                    e.printStackTrace();                }                System.out.println("the result is: " + adminRegion);                //dar.db.updateNewField(db.getMongoCollection(), document, "forSum", 1);            }        });        //dar.closeMongo();    }}